# -*- coding: utf-8 -*-
# copyright: sktime developers, BSD-3-Clause License (see LICENSE file)
"""Unit tests common to all transformers."""

__author__ = ["mloning"]
__all__ = []

import numpy as np
import pandas as pd
import pytest

from sktime.datatypes import check_is_scitype
from sktime.datatypes._panel._check import is_nested_dataframe
from sktime.registry import all_estimators
from sktime.tests._config import EXCLUDE_ESTIMATORS
from sktime.tests.test_all_estimators import BaseFixtureGenerator, QuickTester
from sktime.transformations.base import (
    BaseTransformer,
    _PanelToPanelTransformer,
    _PanelToTabularTransformer,
    _SeriesToPrimitivesTransformer,
    _SeriesToSeriesTransformer,
)
from sktime.utils._testing.estimator_checks import (
    _assert_array_almost_equal,
    _has_capability,
    _make_args,
)

ALL_TRANSFORMERS = all_estimators(
    estimator_types="transformer",
    return_names=False,
    exclude_estimators=EXCLUDE_ESTIMATORS,
)


class TransformerFixtureGenerator(BaseFixtureGenerator):
    """Fixture generator for forecasting tests.

    Fixtures parameterized
    ----------------------
    estimator_class: estimator inheriting from BaseObject
        ranges over all estimator classes not excluded by EXCLUDED_TESTS
    estimator_instance: instance of estimator inheriting from BaseObject
        ranges over all estimator classes not excluded by EXCLUDED_TESTS
        instances are generated by create_test_instance class method
    scenario: instance of TestScenario
        ranges over all scenarios returned by retrieve_scenarios
    """

    # note: this should be separate from TestAllTransformers
    #   additional fixtures, parameters, etc should be added here
    #   TestAllTransformers should contain the tests only

    estimator_type_filter = "transformer"


class TestAllTransformers(TransformerFixtureGenerator, QuickTester):
    """Module level tests for all sktime forecasters."""

    def _expected_trafo_output_scitype(self, X_scitype, trafo_input, trafo_output):
        """Return expected output scitype, given X scitype and input/output.

        Paramaters
        ----------
        X_scitype : str, scitype of the input to transform
        trafo_input : str, scitype of "instance"
        trafo_output : str, scitype that instance is being transformed to

        Returns
        -------
        expected scitype of the output of transform
        """
        # if series-to-series: input scitype equals output scitype
        if trafo_input == "Series" and trafo_output == "Series":
            return X_scitype
        if trafo_output == "Primitives":
            return "Table"
        if trafo_input == "Series" and trafo_output == "Panel":
            if X_scitype == "Series":
                return "Panel"
            if X_scitype in ["Panel", "Hierarchical"]:
                return "Hierarchical"

    def test_fit_transform_output(self, estimator_instance, scenario):
        """Test get_fitted_params."""
        Xt = scenario.run(estimator_instance, method_sequence=["fit", "transform"])

        X_scitype = scenario.get_tag("X_scitype")
        trafo_input = estimator_instance.get_tag("scitype:transform-input")
        trafo_output = estimator_instance.get_tag("scitype:transform-output")

        expected_scitype = self._expected_trafo_output_scitype(
            X_scitype, trafo_input, trafo_output
        )

        valid_scitype = check_is_scitype(Xt, scitype=expected_scitype)

        msg = (
            f"{type(estimator_instance).__name}.transform should return an object of "
            f"scitype {expected_scitype} when given an input of scitype {X_scitype}, "
            f"but found the following return: {Xt}"
        )

        assert valid_scitype, msg

        # todo: also test the expected mtype

    def test_transform_inverse_transform_equivalent(self, estimator_instance, scenario):
        X = scenario.args["transform"]["X"]
        Xt = scenario.run(estimator_instance, method_sequence=["fit", "transform"])
        Xit = estimator_instance.inverse_transform(Xt)
        if estimator_instance.get_tag("transform-returns-same-time-index"):
            _assert_array_almost_equal(X, Xit)
        else:
            _assert_array_almost_equal(X.loc[Xit.index], Xit)



def _construct_fit_transform(Estimator, **kwargs):
    estimator = Estimator.create_test_instance()

    # For forecasters which are also transformations (e.g. pipelines), we cannot
    # the forecasting horizon to transform, so we only return the first two
    # arguments here. Note that this will fail for forecasters which require the
    # forecasting horizon in fit.
    args = _make_args(estimator, "fit", **kwargs)[:2]
    return estimator.fit_transform(*args)


def _construct_fit(Estimator, **kwargs):
    estimator = Estimator.create_test_instance()
    args = _make_args(estimator, "fit", **kwargs)[:2]
    return estimator.fit(*args)

def check_series_to_primitive_transform_univariate(Estimator, **kwargs):
    out = _construct_fit_transform(Estimator, **kwargs)
    assert isinstance(out, pd.DataFrame)

def _check_raises_error(Estimator, **kwargs):
    with pytest.raises(ValueError, match=r"univariate"):
        estimator = Estimator.create_test_instance()
        if estimator.get_tag("fit-in-transform", False):
            # As some estimators have an empty fit method, we here check if
            # they raise the appropriate error in transform rather than fit.
            _construct_fit_transform(Estimator, **kwargs)
        else:
            # All other estimators should raise the error in fit.
            _construct_fit(Estimator, **kwargs)


def check_series_to_primitive_transform_multivariate(Estimator):
    n_columns = 3
    estimator = Estimator.create_test_instance()
    if estimator.get_tag("univariate-only", False):
        _check_raises_error(Estimator, n_columns=n_columns)
    else:
        out = _construct_fit_transform(Estimator, n_columns=n_columns)
        assert isinstance(out, pd.DataFrame)
        # We don't know how many primitives wil be returned, so # of columns unknown.


def check_series_to_series_transform_univariate(Estimator):
    estimator = Estimator.create_test_instance()
    n_timepoints = 15
    out = _construct_fit_transform(
        Estimator,
        n_timepoints=n_timepoints,
        add_nan=estimator.get_tag("handles-missing-data", False),
    )
    assert isinstance(out, (pd.Series, np.ndarray, pd.DataFrame))


def check_series_to_series_transform_multivariate(Estimator):
    estimator = Estimator.create_test_instance()
    n_columns = 3
    n_timepoints = 15
    if estimator.get_tag("univariate-only", False):
        _check_raises_error(Estimator, n_timepoints=n_timepoints, n_columns=n_columns)
    else:
        out = _construct_fit_transform(
            Estimator, n_timepoints=n_timepoints, n_columns=n_columns
        )
        assert isinstance(out, (pd.DataFrame, np.ndarray))
        if estimator.get_tag("transform-returns-same-time-index"):
            assert out.shape[0] == n_timepoints


def check_panel_to_tabular_transform_univariate(Estimator):
    n_instances = 5
    out = _construct_fit_transform(Estimator, n_instances=n_instances)
    assert isinstance(out, (pd.DataFrame, np.ndarray))
    assert out.shape[0] == n_instances


def check_panel_to_tabular_transform_multivariate(Estimator):
    estimator = Estimator.create_test_instance()
    n_instances = 5
    if estimator.get_tag("univariate-only", False):
        _check_raises_error(Estimator, n_instances=n_instances, n_columns=3)
    else:
        out = _construct_fit_transform(Estimator, n_instances=n_instances, n_columns=3)
        assert isinstance(out, (pd.DataFrame, np.ndarray))
        assert out.shape[0] == n_instances


def check_panel_to_panel_transform_univariate(Estimator):
    n_instances = 5
    out = _construct_fit_transform(Estimator, n_instances=n_instances)
    assert isinstance(out, (pd.DataFrame, np.ndarray))
    assert out.shape[0] == n_instances
    if isinstance(out, np.ndarray):
        assert out.ndim == 3
    if isinstance(out, pd.DataFrame):
        assert is_nested_dataframe(out)


def check_panel_to_panel_transform_multivariate(Estimator):
    estimator = Estimator.create_test_instance()
    n_instances = 5
    if estimator.get_tag("univariate-only", False):
        _check_raises_error(Estimator, n_instances=n_instances, n_columns=3)
    else:
        out = _construct_fit_transform(Estimator, n_instances=n_instances, n_columns=3)
        assert isinstance(out, (pd.DataFrame, np.ndarray))
        assert out.shape[0] == n_instances
        if isinstance(out, np.ndarray):
            assert out.ndim == 3
        if isinstance(out, pd.DataFrame):
            assert is_nested_dataframe(out)


def check_transform_returns_same_time_index(Estimator):
    estimator = Estimator.create_test_instance()
    if estimator.get_tag("transform-returns-same-time-index"):
        assert issubclass(Estimator, (_SeriesToSeriesTransformer, BaseTransformer))
        estimator = Estimator.create_test_instance()
        fit_args = _make_args(estimator, "fit")
        estimator.fit(*fit_args)
        for method in ["transform", "inverse_transform"]:
            if _has_capability(estimator, method):
                X = _make_args(estimator, method)[0]
                Xt = estimator.transform(X)
                np.testing.assert_array_equal(X.index, Xt.index)


def check_transform_inverse_transform_equivalent(Estimator):
    estimator = Estimator.create_test_instance()
    X = _make_args(estimator, "fit")[0]
    Xt = estimator.fit_transform(X)
    Xit = estimator.inverse_transform(Xt)
    if estimator.get_tag("transform-returns-same-time-index"):
        _assert_array_almost_equal(X, Xit)
    else:
        _assert_array_almost_equal(X.loc[Xit.index], Xit)
